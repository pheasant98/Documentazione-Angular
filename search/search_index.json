{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Angular","text":"<p>Angular \u00e8 un framework Front-End per lo sviluppo di Single Page Application (SPA), creato e mantenuto da Google. Nato come evoluzione di AngularJS, Angular \u00e8 progettato per facilitare la creazione di applicazioni moderne, scalabili e manutenibili. Grazie a una struttura basata su componenti, una potente gestione delle dipendenze e strumenti integrati per il routing, il form handling e la comunicazione con API, Angular permette agli sviluppatori di costruire interfacce utente dinamiche e performanti.</p> <p>Angular si ispira al pattern architetturale MVC (Model-View-Controller), riorganizzandolo in una forma pi\u00f9 moderna e component-based. In Angular, la View \u00e8 rappresentata dal template HTML, il Model \u00e8 costituito dai dati e dagli oggetti gestiti dai componenti e dai servizi, mentre la Controller logic \u00e8 incorporata direttamente nei componenti attraverso il codice TypeScript. Questa struttura favorisce una netta separazione delle responsabilit\u00e0 e rende il flusso dei dati chiaro e controllato.</p> <p>Ogni componente Angular \u00e8 associato a un file HTML, che definisce la struttura visiva (il template) dell'interfaccia, e a file CSS o SCSS, che gestiscono gli stili e l'aspetto grafico. Questa separazione chiara tra logica, struttura e presentazione aiuta a mantenere il codice organizzato e facilmente manutenibile.</p> <p>Per la logica di business viene utilizzato TypeScript, un superset di JavaScript che introduce la tipizzazione statica, il supporto a classi e interfacce, e avanzate funzionalit\u00e0 di tooling. L\u2019utilizzo di TypeScript migliora la qualit\u00e0 del codice, facilita la manutenzione e consente di sfruttare strumenti di sviluppo pi\u00f9 potenti.</p> <p>Note</p> <p>In questo documento verranno trattate le versioni 7 e 12 di Angular, in quanto compatibili con il framework utilizzato dal cliente XDCE.</p> <p>Info</p> <p>Documentazione Angular 7 Documentazione Angular 12</p>"},{"location":"#angular-mvc","title":"Angular MVC","text":"<p>Il Model-View-Controller (MVC) \u00e8 un design pattern tipicamente utilizzato per lo sviluppo di web applications perch\u00e9 permette la \u201cseparation of concerns\u201d in cui il data model viene separato dalla business e presentation logic.</p> <p>Nel seguente schema viene riportato come MVC \u00e8 stato riorganizzato in una forma component-based.</p> <p> </p> Figura 1: Schema MVC in chiave Angular <p>All'interno del cliente troviamo gli elementi: Model, Component, Template, DOM e Browser Window.</p> <p>Il Model \u00e8 il livello che sa cosa rappresentano i dati e come gestirli, ma non si occupa di come vengono mostrati o come vengono interagiti dall'utente. Perci\u00f2, risiedono i dati dell'applicazione e i servizi che offrono la logica per recuperare e manipolare i dati oltre a fornire chiamate HTTP a API. Inoltre, possono risiedere enum o interfacce che rappresentano la struttura dei dati.</p> <p>Note</p> <p>Non deve esporre i dettagli su come i dati sono ottenuti o gestiti (il web service non deve essere esposto al controller e alle view). Non deve contenere la logica che trasforma i dati rispetto alle interazioni con l\u2019utente (compito del controller). Non deve contenere la logica di visualizzazione dei dati (compito della view).</p> <p>Il Component svolge il ruolo del Controller tradizionale dell'MVC. Ha il compito di gestire la logica dell\u2019interfaccia utente: riceve input dall'utente, reagisce agli eventi (click, input, ecc.), e aggiorna i dati del Model o della View. Percio, il component si occupa di interagire con il Model per fornire dati e comportamenti al template HTML</p> <p>Il Component in Angular \u00e8 composto da:</p> <ul> <li>un file TypeScript (.ts) che contiene la classe con propriet\u00e0 e metodi \u2192 (Controller);</li> <li>un file HTML (.html) che definisce la struttura visiva \u2192 (View);</li> <li>uno o pi\u00f9 file CSS/SCSS (.css o .scss) per gli stili \u2192 (Styling).</li> </ul> <p>Note</p> <p>Non deve gestire la visualizzazione dei dati (non deve modificare il DOM). Non deve gestire la logica di persistenza dei dati (Compito del modello attraverso il web service).</p> <p>Il Template \u00e8 la parte dell'applicazione che definisce come i dati vengono presentati all'utente. Contiene la logica di markup necessaria a presentare i dati all\u2019utente.</p> <p>Il template \u00e8 normalmente scritto in HTML, ma arricchito con funzionalit\u00e0 aggiuntive fornite da Angular, come: - Data binding (legare i dati del componente al template) - Strutture di controllo (es. ngIf, ngFor) - Event binding (es. (click), (input)) - Pipe per la formattazione dei dati</p> <p>Queste funzionalit\u00e0 verrano illustarte nei prossimi capitoli.</p> <p>Note</p> <p>Non deve contenere alcuna logica di modifica, creazione e gestione dei dati.  Non deve contenere la logica dell\u2019applicazione.</p>"},{"location":"#decoratori","title":"Decoratori","text":"<p>Angular sfrutta i decoratori introdotti da TypeScript per \"annotare\" classi, metodi o propriet\u00e0, arricchendoli di metadati e abilitando funzionalit\u00e0 avanzate a runtime.</p> <p>Un esempio tipico \u00e8 il decoratore @Component(), che viene applicato a una classe per indicare che rappresenta un componente Angular. Il decoratore fornisce ad Angular tutte le informazioni necessarie, come il selettore, il template e i file di stile associati.</p> <p>I decoratori possono essere configurati tramite parametri passati al momento della dichiarazione, consentendo una gestione dinamica e personalizzata del comportamento dell'applicazione.</p> Decorator Descrizione @NgModule Definisce un modulo che contiene componenti, direttive, pipe e providers. @Component Dichiara che una classe \u00e8 un componente e ne fornisce i meta-dati. @Injectable Dichiara che una classe ha dipendenze che devono essere iniettate nel costruttore quando il Dependency Injector crea l\u2019istanza della classe. @Directive Dichiara che una classe \u00e8 una direttiva e ne fornisce i metadati. @Pipe Dichiara che una classe \u00e8 una pipe e ne fornisce i metadati. @Input Dichiara una propriet\u00e0 di input che si pu\u00f2 aggiornare con un property binding. @Output Dichiara una propriet\u00e0 di output che emette eventi a cui ci si pu\u00f2 sottoscrivere con un event binding. @HostBinding Effettua il binding di una propriet\u00e0 dell\u2019elemento host ad un propriet\u00e0 o direttiva del componente. @HostListener Sottoscrizione ad un evento dell\u2019elemento host tramite una direttiva o metodo del componente, eventualmente passando un parametro. @ContentChild Esegue una query di selezione dei componenti figli, effettuando il binding del primo risultato ottenuto con una propriet\u00e0 della classe. Si riferisce ai componenti che sono figli del componente corrente nel DOM in cui esso \u00e8 utilizzato. @ContentChildren Esegue una query di selezione dei componenti figli, effettuando il binding dei risultati ottenuti con una propriet\u00e0 della classe. Si riferisce ai componenti che sono figli del componente corrente nel DOM in cui esso \u00e8 utilizzato. @ViewChild Esegue una query di selezione dei componenti figli, effettuando il binding del primo risultato ottenuto con una propriet\u00e0 della classe. Si riferisce ai componenti che sono inseriti nel DOM del template collegato al componente. @ViewChildren Esegue una query di selezione dei componenti figli, effettuando il binding dei risultati ottenuti con una propriet\u00e0 della classe. Si riferisce ai componenti che sono inseriti nel DOM del template collegato al componente."},{"location":"component/","title":"Component","text":"<p>Un componente in Angular \u00e8 un elemento fondamentale che definisce una porzione dell'interfaccia utente, composta da dati e elementi visivi che vengono mostrati nel DOM (vista). Esso incapsula la logica necessaria per gestire l'interazione e il comportamento dell'interfaccia.</p> <p>Un componente \u00e8 costituito da una classe che contiene i dati e la logica ad essi associati. Grazie ai metadati definiti dal decoratore <code>@Component</code>, il componente \u00e8 composto da tre elementi principali:</p> <ul> <li> <p>Template (HTML): Definisce la struttura e la presentazione dell'interfaccia utente. \u00c8 il codice HTML che viene renderizzato quando il componente viene caricato. Il template include codice HTML e pu\u00f2 contenere direttive e binding di dati offerti da Angular, come il binding per propriet\u00e0, eventi, o classi CSS dinamiche.</p> </li> <li> <p>Classe (TypeScript): Contiene la logica del componente. La classe \u00e8 definita in TypeScript e gestisce il comportamento, i dati e le interazioni dell'interfaccia utente. Pu\u00f2 includere propriet\u00e0, metodi e logica per gestire eventi, dati in ingresso e in uscita, e anche per effettuare chiamate API.</p> </li> <li> <p>Stili (CSS/SCSS): Ogni componente pu\u00f2 avere stili CSS o SCSS associati che ne determinano l'aspetto visivo. Questi stili sono applicati solo al componente specifico, grazie all'incapsulamento degli stili, evitando conflitti con altri componenti dell'applicazione.</p> </li> </ul> <p> </p> Figura 3: Schema Component <p>Vediamo un esempio di semplice component:</p> <p>Example</p> <pre><code>import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-hello-world',  \n  templateUrl: './hello-world.component.html',\n  styleUrls: ['./hello-world.component.css']\n})\nexport class HelloWorldComponent {\n\n  public message: string;\n\n  constructor(){\n    this.message = 'Ciao mondo! Benvenuto su Angular!';\n  }\n\n}\n</code></pre> <p>Grazie al decoratore <code>@Component</code> possiamo definire il component con i seguenti metadati:</p> <ul> <li> <p>selector: definisce il nome del tag HTML personalizzato che Angular usa per individuare dove istanziare e rendere visibile il componente. Ad esempio, se il template contiene <code>&lt;app-hello-world&gt;&lt;/app-hello-world&gt;</code>, Angular rileva il tag e monta un'istanza di <code>HelloWorldComponent</code> in quella posizione.</p> </li> <li> <p>templateUrl: indica il percorso relativo al file HTML che definisce la vista del componente. In alternativa, \u00e8 possibile specificare il template direttamente nel codice tramite la propriet\u00e0 template.</p> </li> <li> <p>styleUrls: specifica uno o pi\u00f9 percorsi ai file CSS (o SCSS) che contengono gli stili applicati solo al componente. Gli stili definiti in questi file si applicano in modo isolato al componente, grazie all'incapsulamento dello stile che Angular applica di default (ViewEncapsulation).</p> </li> </ul> <p>Info</p> <p>In Angular, ViewEncapsulation controlla come gli stili CSS definiti in un componente vengono applicati:   - Solo al componente stesso (incapsulamento).   - Oppure si propagano anche agli altri elementi HTML (come avviene normalmente nel browser).</p> <p>L'obiettivo principale \u00e8 isolare gli stili di un componente, evitando che \"inquinino\" altri componenti o che vengano sovrascritti da stili esterni.</p> <p>Angular fornisce tre modalit\u00e0 principali:</p> Tipo Descrizione Effetto pratico Emulated (predefinito) Simula l'incapsulamento degli stili. Angular aggiunge attributi HTML personalizzati ai selettori CSS per limitare l'ambito. Gli stili sono applicati solo al componente e ai suoi figli. None Nessun incapsulamento: gli stili sono globali. Gli stili si propagano ovunque nell'applicazione. ShadowDom Usa direttamente il vero Shadow DOM del browser (se disponibile). Gli stili sono naturalmente isolati grazie al browser. <p>Il ViewEncapsulation puo essere configurato nella proprieta encapsulation di <code>@Component</code>:</p> <pre><code>  import { Component, ViewEncapsulation } from '@angular/core';\n\n  @Component({\n    selector: 'app-example',\n    templateUrl: './example.component.html',\n    styleUrls: ['./example.component.css'],\n    encapsulation: ViewEncapsulation.Emulated // (default)\n  })\n  export class ExampleComponent { }\n</code></pre> <p>Non \u00e8 stato riportato nell'esempio del component <code>HelloWorldComponent</code>, esiste anche la proprieta <code>providers</code>che permette di dichiarare i servizi di cui il componente ha bisogno. Angular crea un'istanza locale di quel servizio solo per quel componente e per i suoi figli. Questo meccanismo \u00e8 alla base del sistema di Dependency Injection di Angular. Approfondiremo l'argomento nel capitolo dedicato ai servizi.</p> <p>Note</p> <p>In Angular esiste la convenzione di dare come nome della classe del componente usando il PascalCase: I nomi delle classi devono iniziare con una lettera maiuscola e ogni nuova parola deve iniziare con una maiuscola.</p> <p>Esempio: <code>HelloWorldComponent</code></p> <p>per coerenza il nome della classe deve riflettere il nome del file in  kebab-case: I selettori devono essere in minuscolo e separati da trattini.</p> <p>File: <code>hello-word.component.ts</code></p> <p>Analogamente anche il selettore deve essere in kebab-case aggiungendo un prefisso.</p> <p><code>selector: 'app-hello-world'</code>,</p> <p>solitamente si utilizza il prefisso app- ma a seconda delle norme interne dell'azienda puo essere stabilito un altro dipo di prefisso.</p>"},{"location":"component/#templates-e-views","title":"Templates e views","text":"<p>In Angular, le viste non sono necessariamente costituite da un singolo componente con il suo template, ma \u00e8 altamente consigliato adottare una struttura gerarchica di componenti, che possono formare l'intera vista o semplicemente un singolo widget. Questa gerarchia permette di gestire in modo efficiente la visibilit\u00e0 e la modifica di sezioni o pagine dell'interfaccia utente, trattandole come un'unica entit\u00e0 coesa.</p> <p> </p> Figura 4: Schema gerarchia di components <p>Come si pu\u00f2 osservare nell'immagine precedente, il template radice \u00e8 costituito da un insieme di componenti figli, che a loro volta possono includere altre viste, dando cos\u00ec origine a una gerarchia di componenti.</p> <p>Note</p> <p>Una gerarchia di viste pu\u00f2 comprendere componenti appartenenti allo stesso NgModule, ma anche componenti definiti in NgModule differenti. </p>"},{"location":"component/#sintassi-template","title":"Sintassi Template","text":"<p>Un template \u00e8 simile a un normale HTML, ma include anche la sintassi specifica di Angular, che modifica l'HTML in base alla logica dell'applicazione e allo stato dei dati del DOM. Nel template puoi utilizzare il data binding per sincronizzare i dati dell'applicazione con quelli del DOM, le pipe per trasformare i dati prima che vengano visualizzati, e le directive per applicare la logica dell'applicazione a ci\u00f2 che viene mostrato.</p> <p>Vediamo un esempio di template: </p> <p>Example</p> <pre><code>  &lt;!-- hero-list.component.html --&gt;\n  &lt;div class=\"hero-list\"&gt;\n    &lt;h2&gt;Lista degli Eroi&lt;/h2&gt;\n\n    &lt;!-- Interpolazione (data binding) --&gt;\n    &lt;p&gt;Benvenuto, {{ user.name }}!&lt;/p&gt;\n\n    &lt;!-- Data binding per l'attributo --&gt;\n    &lt;img [src]=\"user.imageUrl\" alt=\"{{ user.name }}\"&gt;\n\n    &lt;!-- Diretiva condizionale --&gt;\n    &lt;div *ngIf=\"heroSelected\"&gt;\n      &lt;p&gt;L'eroe \u00e8 selezionato!&lt;/p&gt;\n    &lt;/div&gt;\n\n    &lt;ul&gt;\n      &lt;!-- Event binding --&gt;\n      &lt;li *ngFor=\"let hero of heroes\" (click)=\"selectHero(hero)\"&gt;{{ hero.name }}&lt;/li&gt;\n    &lt;/ul&gt;\n\n    &lt;!-- ngSwitch per visualizzare informazioni in base all'eroe selezionato --&gt;\n    &lt;div [ngSwitch]=\"heroSelected.name\"&gt;\n      &lt;div *ngSwitchCase=\"'Iron Man'\"&gt;\n        &lt;h3&gt;Iron Man&lt;/h3&gt;\n        &lt;p&gt;Iron Man \u00e8 un genio miliardario, playboy e filantropo che combatte per la giustizia!&lt;/p&gt;\n      &lt;/div&gt;\n      &lt;div *ngSwitchCase=\"'Spider-Man'\"&gt;\n        &lt;h3&gt;Spider-Man&lt;/h3&gt;\n        &lt;p&gt;Spider-Man \u00e8 un giovane eroe che utilizza i suoi poteri per proteggere New York!&lt;/p&gt;\n      &lt;/div&gt;\n      &lt;div *ngSwitchDefault&gt;\n        &lt;h3&gt;Eroe Non Selezionato&lt;/h3&gt;\n        &lt;p&gt;Seleziona un eroe dalla lista per visualizzare ulteriori dettagli!&lt;/p&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;!-- Componente Figlio con Two-Way Data Binding --&gt;\n    &lt;app-hero-detail [hero]=\"heroSelected\" (heroSelected)=\"onHeroSelectedDetails($event)\"&gt;&lt;/app-hero-detail&gt;\n  &lt;/div&gt;\n</code></pre> <p>Nelle seguenti sezioni verrano illustarte tutti i nuovi costrutti di Angular.</p>"},{"location":"component/#direttive-build-in","title":"Direttive Build-In","text":"<p>In Angular, esistono delle direttive built-in, ossia direttive predefinite fornite direttamente dal framework, che permettono di controllare il comportamento, l'aspetto o la struttura del DOM in modo dinamico. Sono strumenti molto potenti perch\u00e9 consentono di modificare la pagina HTML in base allo stato dell'applicazione senza dover manipolare direttamente il DOM con JavaScript.</p> <p>Possiamo dividere le direttive built-in in due grandi categorie:  - direttive strutturali:   - ngIf   - ngSwitch   - *ngFor - direttive di attributo:  - ngClass  - ngStyle</p>"},{"location":"component/#ngif","title":"*ngIf","text":"<p>La direttiva <code>*ngIf</code> \u00e8 una direttiva strutturale built-in fornita da Angular. Permette di aggiungere o rimuovere dinamicamente un elemento dal DOM (Document Object Model) in base a una condizione booleana. Quando la condizione associata a <code>*ngIf</code> \u00e8 vera, l'elemento (o il blocco di contenuto) viene aggiunto al DOM. Al contrario, se la condizione \u00e8 falsa, l'elemento viene completamente rimosso dal DOM.</p> <p>Quando un elemento viene rimosso tramite <code>*ngIf</code>, non viene semplicemente nascosto, ma viene effettivamente eliminato dal DOM. Di conseguenza, ogni volta che la condizione cambia e l'elemento viene reinserito, viene creato nuovamente, perdendo qualsiasi stato precedente.</p> <p>Example</p> <pre><code>&lt;div *ngIf=\"heroSelected\"&gt;\n  &lt;p&gt;L'eroe \u00e8 selezionato!&lt;/p&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"component/#ngswitch","title":"ngSwitch","text":"<p>La direttiva <code>ngSwitch</code> \u00e8 una direttiva strutturale di Angular che permette di gestire la visualizzazione condizionale di blocchi di codice all'interno di un template. Si utilizza per implementare un comportamento simile a un'istruzione switch-case in altri linguaggi di programmazione, dove diverse condizioni vengono verificate e il blocco di codice associato al caso corrispondente viene eseguito.</p> <p>Example</p> <pre><code>&lt;div [ngSwitch]=\"heroSelected.name\"&gt;\n  &lt;div *ngSwitchCase=\"'Iron Man'\"&gt;\n    &lt;h3&gt;Iron Man&lt;/h3&gt;\n    &lt;p&gt;Iron Man \u00e8 un genio miliardario, playboy e filantropo che combatte per la giustizia!&lt;/p&gt;\n  &lt;/div&gt;\n  &lt;div *ngSwitchCase=\"'Spider-Man'\"&gt;\n    &lt;h3&gt;Spider-Man&lt;/h3&gt;\n    &lt;p&gt;Spider-Man \u00e8 un giovane eroe che utilizza i suoi poteri per proteggere New York!&lt;/p&gt;\n  &lt;/div&gt;\n  &lt;div *ngSwitchDefault&gt;\n    &lt;h3&gt;Eroe Non Selezionato&lt;/h3&gt;\n    &lt;p&gt;Seleziona un eroe dalla lista per visualizzare ulteriori dettagli!&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>In questo esempio:</p> <ul> <li><code>ngSwitch</code> \u00e8 la direttiva che viene applicata all'elemento contenitore e associa un'espressione da valutare.</li> <li><code>ngSwitchCase</code> viene applicato agli elementi figlio del contenitore e rappresenta un singolo caso da confrontare con il valore dell'espressione.</li> </ul>"},{"location":"component/#ngfor","title":"*ngFor","text":"<p>La direttiva <code>*ngFor</code> \u00e8 una direttiva strutturale di Angular che permette di iterare su una collezione di dati, come un array o una lista, e generare dinamicamente un elemento del DOM per ogni elemento della collezione.</p> <p>Example</p> <pre><code>&lt;ul&gt;\n  &lt;li *ngFor=\"let hero of heroes\"&gt;{{ hero.name }}&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre> <p>In questo esempio:</p> <ul> <li><code>let hero</code> \u00e8 la variabile che rappresenta ciascun elemento dell'array durante l'iterazione.</li> <li><code>heroes</code> \u00e8 la collezione di dati che si desidera iterare.</li> </ul> <p>In Angular, puoi utilizzare l'attributo index all'interno della direttiva <code>*ngFor</code> per ottenere l'indice dell'elemento corrente nell'iterazione. L'indice \u00e8 numerato a partire da 0 per il primo elemento.</p> <p>Example</p> <pre><code>&lt;div *ngFor=\"let hero of heroes; let i = index\"&gt;\n  &lt;p&gt;{{ i }}: {{ item }}&lt;/p&gt;\n&lt;/div&gt;\n</code></pre> <p>In questo esempio:</p> <ul> <li><code>let i = index</code> definisce una variabile i che rappresenta l'indice dell'elemento corrente.</li> <li><code>{{ i }}</code> stampa l'indice dell'elemento nell'array, tramite interpolazione (lo vedremmo nella sezione successiva dedicata al data binding).</li> </ul> <p>Tip</p> <p>La direttiva <code>trackBy</code> in Angular \u00e8 una funzionalit\u00e0 avanzata che viene utilizzata insieme a <code>*ngFor</code> per migliorare le prestazioni quando si lavora con liste dinamiche. <code>trackBy</code> permette ad Angular di identificare univocamente gli elementi all'interno di una lista, in modo che l'engine di rendering possa determinare con maggiore precisione quali elementi sono cambiati, aggiunti o rimossi, evitando di rifare il rendering dell'intera lista ogni volta che cambia uno degli elementi, ma solo degli elementi che sono cambiati.</p> <p>Sintassi:</p> <p><pre><code>&lt;li *ngFor=\"let hero of heroes; trackBy: trackByHeroId\"&gt;\n  {{ item.name }}\n&lt;/li&gt;\n</code></pre> <code>trackBy: trackByHeroId</code> specifica una funzione personalizzata che Angular utilizza per identificare in modo univoco ogni elemento nella lista. Questa funzione deve restituire un valore univoco per ogni elemento.</p> <pre><code>trackByHeroId(index: number, hero: Hero): number {\n    return hero.id;\n}\n</code></pre> <p><code>trackByHeroId</code> \u00e8 una funzione che restituisce <code>hero.id</code>, un valore univoco per ogni eroe. Questo permette ad Angular di tracciare ogni elemento della lista in modo efficiente.</p>"},{"location":"component/#ngclass","title":"ngClass","text":"<p><code>ngClass</code> permette di aggiungere, rimuovere o cambiare classi CSS su un elemento HTML in modo dinamico. \u00c8 molto utile quando vogliamo applicare stili diversi in base a condizioni specifiche senza dover scrivere logica complicata nel template.</p> <p>Example</p> <pre><code>&lt;div [ngClass]=\"{'active': isActive, 'disabled': !isActive}\"&gt;\n  Pulsante\n&lt;/div&gt;\n</code></pre> <p>Se <code>isActive</code> \u00e8 true, il div ricever\u00e0 la classe active; altrimenti ricever\u00e0 la classe disabled. ngClass pu\u00f2 accettare anche array di classi o semplici stringhe di classi separate da spazi.</p>"},{"location":"component/#ngstyle","title":"ngStyle","text":"<p><code>ngStyle</code> permette di applicare stili CSS direttamente sull\u2019elemento HTML in maniera dinamica, senza dover passare attraverso le classi.</p> <p>Example</p> <pre><code>&lt;div [ngStyle]=\"{'color': isActive ? 'green' : 'red', 'font-size': '20px'}\"&gt;\n  Testo dinamico\n&lt;/div&gt;\n</code></pre> <p>Il colore del testo sar\u00e0 verde se <code>isActive</code> \u00e8 true, oppure rosso se <code>isActive</code> \u00e8 false, e avr\u00e0 sempre una dimensione del font di 20px.</p>"},{"location":"component/#data-binding","title":"Data Binding","text":"<p>Il data binding \u00e8 il meccanismo che collega i dati del componente alla vista (template HTML) e viceversa. Oltre a gestire l'interazione tra logica e interfaccia, il data binding consente anche il passaggio di dati tra componenti lungo la loro gerarchia, facilitando cos\u00ec la comunicazione tra componenti padre e figlio.</p> <p>Grazie al data binding, \u00e8 possibile aggiornare dinamicamente la visualizzazione dei dati nella pagina e gestire in modo reattivo gli eventi dell'utente, come click, input o cambiamenti di stato.</p> <p>Angular offre quattro principali modalit\u00e0 di data binding:</p> Tipo Descrizione Sintassi Interpolazione Collega dati dal componente alla vista, per visualizzare valori. <code>{{ propriet\u00e0 }}</code> Property Binding Collega dati dal componente ad attributi/propriet\u00e0 HTML. <code>[attributo]=\"propriet\u00e0\"</code> Event Binding Collega eventi della vista al metodo del componente. <code>(evento)=\"metodo()\"</code> Two-way Binding Sincronizza dati in entrambe le direzioni tra componente e vista. <code>[(ngModel)]=\"propriet\u00e0\"</code> <p> </p> Figura 5: Schema tipologie di data binding"},{"location":"component/#interpolazione","title":"Interpolazione ({{ }})","text":"<p>Permette di inserire valori direttamente nell'HTML </p> <p>Example</p> <pre><code>export interface Hero {\n  name: string;\n  surname: string;\n  isSelected: boolean;\n  imageUrl: string;\n  creationDate: string;\n}\n\n...\n\nexport class HelloWorldComponent {\n\n  public user: Hero;\n\n  constructor(){\n    this.user = {name: Mario,\n      surname: Rossi,\n      imageUrl:'./assets/logo.png',\n    };\n  }\n\n}\n</code></pre> <p>Nel template: </p> <p>Example</p> <pre><code>&lt;p&gt;Benvenuto, {{ user.name }}!&lt;/p&gt;\n</code></pre> <p>Nell'esempio grazie alla interpolazione \u00e8 possibile visualizzare valori salvati in una variabile o in un campo di oggetto all'interno dell'HTML.</p>"},{"location":"component/#property-binding","title":"Property Binding ([ ])","text":"<p>Collega una propriet\u00e0 del componente a una propriet\u00e0 HTML o di un componente figlio.</p> <p>Riprendendo il ts precedente: </p> <p>Example</p> <pre><code>&lt;img [src]=\"user.imageUrl\" alt=\"{{ user.name }}\"&gt;\n</code></pre>"},{"location":"component/#event-binding","title":"Event Binding (( ))","text":"<p>Permette di rispondere agli eventi dell'utente, come click, input, submit, ecc.</p> <p>Example</p> <pre><code>&lt;li *ngFor=\"let hero of heroes\" (click)=\"selectHero(hero)\"&gt;{{ hero.name }}&lt;/li&gt;\n</code></pre> <p>Nel componente:</p> <p>Example</p> <pre><code>public selectHero(hero: Hero):void{\n  this.selectedHero = hero;\n}\n</code></pre> <p>Quando l'utente clicca il pulsante, verr\u00e0 eseguito il <code>selectHero</code> passando l'elemento cliccato.</p>"},{"location":"component/#two-way-binding","title":"Two-way Binding ([( )])","text":"<p>Combina property binding ed event binding: sincronizza il valore sia dal componente alla vista, sia dalla vista al componente.</p> <p>Example</p> <pre><code>&lt;input [(ngModel)]=\"hero.nome\"&gt;\n&lt;p&gt;Hai scritto: {{ hero.nome }}&lt;/p&gt;\n</code></pre> <p>Grazie alla direttiva <code>ngModel</code> un valore di propriet\u00e0 dati scorre nella casella di input dal componente come con l\u2019associazione di propriet\u00e0. Le modifiche dell\u2019utente tornano anche al componente, reimpostando la propriet\u00e0 sul valore pi\u00f9 recente, come con l\u2019associazione di eventi.</p> <p>Inoltre grazie al Two-way Binding \u00e8 pssibile la comunicazione tra componenti padre e figlio.</p> <p>Nel template padre:</p> <p>Example</p> <pre><code>&lt;app-hero-detail [hero]=\"hero\" (heroSelected)=\"onHeroSelectedDetails($event)\"&gt;&lt;/app-hero-detail&gt;\n</code></pre> <p>Nel component figlio:</p> <p>Example</p> <pre><code>...\nexport class HeroDetailComponent {\n  @Input() hero: Hero = '';\n  @Output() heroSelected: EventEmitter&lt;string&gt; = new EventEmitter&lt;string&gt;();\n\n  onDetails(details: string) {\n    this.heroSelected.emit(details);\n  }\n}\n</code></pre> <p>Tramite la sintassi <code>[hero]=\"hero\"</code>, il padre passa al figlio un oggetto Hero, sfruttando il meccanismo del property binding di Angular. Il valore assegnato all'input del figlio (<code>@Input() hero</code>) viene quindi popolato direttamente con l'oggetto fornito dal padre.</p> <p>Allo stesso tempo, il padre si mette in ascolto dell'evento personalizzato (<code>heroSelected</code>). Questo evento viene definito nel figlio usando <code>@Output()</code> e un <code>EventEmitter&lt;string&gt;</code>, che consente al figlio di notificare al padre un'azione o un cambiamento. Quando il figlio esegue il metodo <code>onDetails(details: string)</code>, chiama <code>this.heroSelected.emit(details)</code>, emettendo cos\u00ec l'evento verso il padre. Il padre intercetta l'evento attraverso la sintassi <code>(heroSelected)=\"onHeroSelected($event)\"</code>, richiamando il proprio metodo onHeroSelected e passando come parametro il valore emesso dal figlio.</p> <p>Ci\u00f2 che viene emesso dal component figlio \u00e8 ricavabile dal padre attraverso la variabile <code>$event</code>.</p>"},{"location":"component/#ciclo-di-vita-di-un-componente-lifecycle","title":"Ciclo di vita di un componente (Lifecycle)","text":"<p>Gli Angular Lifecycle Hooks (metodi del ciclo di vita) permettono di eseguire codice in momenti specifici della vita di un componente o di una direttiva. Ogni hook corrisponde a una fase precisa: dall'inizializzazione alla distruzione. </p> Hook Descrizione <code>ngOnChanges()</code> Viene eseguito ogni volta che cambia il valore di una propriet\u00e0 di input. Si attiva prima dell'inizializzazione del componente e ogni volta che uno degli input viene modificato. <code>ngOnInit()</code> Rappresenta la fase di inizializzazione del componente. Viene eseguito una sola volta dopo il primo <code>ngOnChanges()</code>. <code>ngDoCheck()</code> Metodo richiamato durante il controllo interno di Angular per intercettare modifiche ai dati o allo stato dei componenti. Segue ogni esecuzione di <code>ngOnChanges()</code> e <code>ngOnInit()</code>. <code>ngAfterContentInit()</code> Eseguito dopo che Angular ha proiettato il contenuto nel componente. Viene chiamato una sola volta, immediatamente dopo il primo <code>ngDoCheck()</code>. <code>ngAfterContentChecked()</code> Richiamato dopo ogni verifica del contenuto proiettato. Si attiva dopo <code>ngAfterContentInit()</code> e successivamente a ogni <code>ngDoCheck()</code>. <code>ngAfterViewInit()</code> Indica che la vista e i componenti figli sono stati inizializzati. \u00c8 eseguito una sola volta dopo <code>ngAfterContentChecked()</code>. <code>ngAfterViewChecked()</code> Si verifica dopo ogni verifica della vista del componente. Chiamato dopo <code>ngAfterViewInit()</code> e successivamente a ogni <code>ngAfterContentChecked()</code>. <code>ngOnDestroy()</code> Ultima fase del ciclo di vita: chiamato immediatamente prima che Angular distrugga il componente. Serve per liberare risorse, annullare sottoscrizioni e rimuovere event handler per evitare memory leaks."},{"location":"component/#ng-template","title":"ng-template","text":"<p><code>ng-template</code> \u00e8 un contenitore invisibile per contenuto che Angular non renderizza immediatamente nel DOM. Il contenuto all'interno di un ng-template viene creato e inserito solo quando serve, ad esempio in base a condizioni o strutture dinamiche </p> <p>Example</p> <pre><code>&lt;div *ngIf=\"customerData; else loading\"&gt;\n\n&lt;ng-template #loading&gt;\n  &lt;p&gt;Caricamento in corso...&lt;/p&gt;\n&lt;/ng-template&gt;\n</code></pre> <p>Il paragrafo sar\u00e0 creato solo se customerData \u00e8 false, senza aggiungere elementi extra nel DOM. Viene creato un riferimento nel <code>ng-template</code>(<code>#loading</code>) per indicare a che condizione deve riferirsi.</p>"},{"location":"component/#ng-content","title":"ng-content","text":"<p><code>ng-content</code> \u00e8 usato per realizzare il content projection, ovvero per permettere di inserire contenuto dinamico dentro un componente da parte del suo genitore. Il componente definisce un punto (<code>&lt;ng-content&gt;</code>) in cui chi lo usa pu\u00f2 \"iniettare\" del contenuto HTML.</p> <p>Grazie a <code>ng-content</code> possiamo rendere i componenti riutilizzabili e flessibili, lasciando scegliere all'esterno cosa mostrare dentro.</p> <p>Esempio:</p> <p>Nel componente figlio app-card:</p> <p>Example</p> <pre><code>&lt;div class=\"card\"&gt;\n  &lt;ng-content&gt;&lt;/ng-content&gt;\n&lt;/div&gt;\n</code></pre> <p>Nel componente padre:</p> <p>Example</p> <pre><code>&lt;app-card&gt;\n  &lt;p&gt;Questo paragrafo sar\u00e0 proiettato dentro la card!&lt;/p&gt;\n&lt;/app-card&gt;\n</code></pre> <p>Il tag <code>&lt;p&gt;</code> viene automaticamente inserito dove si trova <code>&lt;ng-content&gt;</code> nel figlio.</p>"},{"location":"component/#ng-container","title":"ng-container","text":"<p><code>ng-container</code> \u00e8 un contenitore logico che permette di raggruppare pi\u00f9 elementi senza creare nuovi nodi nel DOM. Serve soprattutto quando vogliamo applicare direttive strutturali come <code>*ngIf</code>, <code>*ngFor</code>, <code>ngSwitch</code> su pi\u00f9 elementi contemporaneamente, senza introdurre tag superflui come <code>&lt;div&gt;</code>.</p> <p><code>ng-container</code> non si vede nel DOM: il browser non renderizza nulla per esso.</p> <p>Example</p> <pre><code>&lt;ng-container *ngIf=\"isLoggedIn\"&gt;\n  &lt;p&gt;Benvenuto!&lt;/p&gt;\n  &lt;button&gt;Logout&lt;/button&gt;\n&lt;/ng-container&gt;\n</code></pre> <p>Il paragrafo e il bottone saranno creati solo se <code>isLoggedIn</code> \u00e8 vero, senza aggiungere elementi extra nel DOM.</p>"},{"location":"direttive/","title":"Direttive personalizzate","text":"<p>In Angular, le direttive personalizzate sono classi che permettono di modificare il comportamento o l'aspetto degli elementi del DOM a cui sono associate. Si creano attraverso il decoratore <code>@Directive</code>.</p> <p>Example</p> <pre><code>import { Directive, ElementRef, Renderer2, HostListener } from '@angular/core';\n\n@Directive({\nselector: '[appEvidenzia]' // uso: &lt;p appEvidenzia&gt;Testo&lt;/p&gt;\n})\nexport class EvidenziaDirective {\n    constructor(private el: ElementRef, private renderer: Renderer2) {}\n\n    @HostListener('mouseenter') onMouseEnter() {\n        this.renderer.setStyle(this.el.nativeElement, 'backgroundColor', 'yellow');\n    }\n\n    @HostListener('mouseleave') onMouseLeave() {\n        this.renderer.removeStyle(this.el.nativeElement, 'backgroundColor');\n    }\n}\n</code></pre> <p>Il codice precedentemente mostrato crea una direttiva personalizzata in Angular per modificare l\u2019aspetto di un elemento HTML al passaggio del mouse. In particolare, questa direttiva imposta uno sfondo giallo quando il cursore si trova sopra l\u2019elemento, e lo rimuove quando il cursore esce. <code>HostListener</code> consente di catturare eventi DOM sull\u2019elemento host (come mouseenter, click, ecc.). La variabile <code>el</code> rappresenta l\u2019elemento DOM su cui \u00e8 applicata la direttiva. Il servizio <code>renderer</code> consente di modificare il DOM in modo compatibile con le varie piattaforme (es. server-side rendering), infatti permette di impostare lo stile.</p> <p>Per usare la direttiva in un componente, basta aggiungerla come attributo: </p> <p>Example</p> <pre><code>&lt;p appEvidenzia&gt;Passa il mouse su questo paragrafo&lt;/p&gt;\n</code></pre>"},{"location":"moduli/","title":"NgModule","text":"<p>Le applicazioni Angular sono composte da blocchi chiamati moduli o NgModules. Un modulo in Angular \u00e8 una raccolta logica di componenti, direttive, pipe e servizi, raggruppati nello stesso contesto di compilazione. Un NgModule pu\u00f2 inoltre importare funzionalit\u00e0 da altri moduli ed esportare le proprie, rendendole disponibili ad altre parti dell'applicazione. Ne conseguono i vantaggi di una chiara organizzazione dell'applicazione e dalla posibilit\u00e0 di riuso del codice.</p> <p>Note</p> <p>Le principali librerie integrate di Angular sono organizzate in NgModules, ad esempio:  - <code>HttpClientModule</code> da <code>@angular/common/http</code>  - <code>FormsModule</code> da <code>@angular/forms</code></p>"},{"location":"moduli/#struttura","title":"Struttura","text":"<p>Ogni applicazione Angular ha almeno un modulo principale, detto root module, che per convenzione viene chiamato AppModule. Il root module definisce come effettuare il bootstrapping dell\u2019applicazione, ovvero quali componenti \"root\" inserire inizialmente nella pagina.</p> <p> </p> Figura 2: Schema Angular Module <p>Un modulo Angular viene definito tramite una classe decorata con il decorator <code>@NgModule</code>. Questo decorator riceve come parametro un oggetto che descrive i metadati del modulo:</p> <ul> <li> <p><code>declarations</code>: i componenti, i servizi, le direttive e le pipe dichiarate all'interno del modulo;</p> </li> <li> <p><code>exports</code>: componenti, direttive o pipe che il modulo rende disponibili ad altri moduli;</p> </li> <li> <p><code>imports</code>: gli altri moduli i cui componenti o servizi sono necessari a questo modulo;</p> </li> <li> <p><code>providers</code>: i servizi disponibili tramite dependency injection all'interno dell'applicazione.</p> </li> <li> <p><code>bootstrap</code>: usato solo nel root module, specifica il componente principale che Angular deve creare e inserire nel DOM quando viene avviata l'applicazione.</p> </li> </ul> <p>Note</p> <p>Affinch\u00e9 il browser possa accedere al codice contenuto nei moduli importati, \u00e8 necessario specificare dove si trovano questi moduli. A questo scopo si utilizzano i moduli TypeScript, che descrivono l'associazione tra gli oggetti esportati e i file nei quali il codice \u00e8 stato definito.  Per esempio: <pre><code>import { CommonModule } from '@angular/common';\n</code></pre></p> <p>Example</p> <pre><code>import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { AppComponent } from './app.component';\nimport { LoggerService } from './logger.service';\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    CommonModule\n  ],\n  providers: [\n    LoggerService \n  ],\n  exports: [\n    AppComponent\n  ]\n})\nexport class AppModule { } //Angular module\n</code></pre>"},{"location":"moduli/#forroot","title":"forRoot( )","text":"<p>Il metodo <code>forRoot()</code> permette di dichiarare che un modulo fornisce dei servizi tramite il campo providers, i quali devono essere registrati una sola volta all'interno del modulo principale dell'applicazione. \u00c8 utile utilizzare <code>forRoot()</code> quando si desidera che un servizio di un modulo sia gestito come singleton, ovvero che esista un'unica istanza condivisa in tutta l'applicazione.</p> <p>Il <code>forRoot()</code> \u00e8 un metodo statico che accetta una configurazione opzionale e restituisce un oggetto di tipo <code>ModuleWithProviders&lt;T&gt;</code> che include un array di provider. Tutti i provider registrati attraverso <code>forRoot()</code> vengono caricati in modo eager, cio\u00e8 immediatamente all'avvio dell'applicazione.</p> <p>Esempio:</p> <p>Supponiamo di avere un <code>CustomMenuModule</code> che fornisce un servizio <code>MenuService</code>.</p> <p>Example</p> <pre><code>//custom-menu.module.ts\n@NgModule({\n  declarations: [MenuComponent],\n  exports: [MenuComponent]\n})\nexport class CustomMenuModule {\n  static forRoot(config: MenuConfig): ModuleWithProviders&lt;CustomMenuModule&gt; {\n    return {\n      ngModule: CustomMenuModule,\n      providers: [\n        { provide: MenuConfig, useValue: config },\n        MenuService\n      ]\n    };\n  }\n}\n</code></pre> <p>Il <code>forRoot()</code> ritorna l'oggetto <code>ModuleWithProviders</code>, che restituisce un modulo insieme a suoi provider, in questo caso <code>MenuService</code> e la sua configurazione. Se non viene ritornato un oggetto <code>ModuleWithProviders</code>, Angular non sa che insieme al modulo che provider registrare.</p> <p>Quindi in providers registriamo <code>MenuService</code> una sola volta.</p> <p>Nel <code>AppModule</code> importiamo <code>CustomMenuModule</code> indicando una configurazione al men\u00f9</p> <p>Example</p> <pre><code>//app.module.ts\nimports: [\n  CustomMenuModule.forRoot({ theme: 'dark' })\n]\n</code></pre>"},{"location":"moduli/#forchild","title":"forChild( )","text":"<p>Il metodo <code>forChild()</code> permette di importare un modulo senza reimpostare anche i provider definiti in <code>forRoot()</code>. Permette quindi di utilizzare solo i componenti di un modulo in altre parti dell'applicazione senza duplicare/ridefinire i servizi.</p> <p>Note</p> <p>il metodo statico <code>forChild()</code> non accetta configurazioni e non registra nuovi provider. Serve solo per importare componenti, direttive, e pipe.</p> <p>Esempio:</p> <p>Se vogliamo aggiungere il <code>forChild()</code> nel <code>customerMenu</code>.</p> <p>Example</p> <pre><code>//custom-menu.module.ts\nstatic forChild(): ModuleWithProviders&lt;CustomMenuModule&gt; {\n  return {\n    ngModule: CustomMenuModule,\n    providers: [] // Nessun provider\n  };\n}\n</code></pre> <p>Dove lo importiamo usiamo il <code>forChild()</code>.</p> <p>Example</p> <pre><code>//app.module.ts\nimports: [\n  CustomMenuModule.forChild()\n]\n</code></pre> <p>Il <code>forChild()</code> risulta utile per due motivi principali:</p> <ul> <li> <p>Definire le rotte nei moduli secondari:     Per esempio, si immagini di avere un'applicazione di e-commerce. Nel modulo principale si stabiliscono le rotte principali una sola volta tramite <code>forRoot()</code>, come la Home, la pagina dei Prodotti, il Carrello, ecc.. . Nei moduli secondari, invece, si usano le rotte tramite forChild per aggiungere rotte specifiche relative solo a quel modulo. Ad esempio, nel modulo che gestisce i prodotti, si potrebbero definire rotte come il dettaglio del prodotto o la pagina per la modifica di un prodotto.</p> </li> <li> <p>Abilitare il Lazy Loading:     <code>forChild()</code> \u00e8 anche essenziale per implementare il lazy loading, una tecnica che consente di caricare i moduli solo quando sono effettivamente necessari. Questo permette di ottimizzare le prestazioni dell'applicazione, caricando solo il codice relativo alle funzionalit\u00e0 richieste dall'utente, riducendo cos\u00ec il tempo di caricamento iniziale.</p> </li> </ul> <p>Info</p> Metodo Dove si usa Cosa fa <code>forRoot()</code> Nel <code>AppModule</code> (root module) Registra servizi/providers (singleton) <code>forChild()</code> Nei feature module o lazy module Usa solo componenti/direttive/pipe, senza duplicare servizi"},{"location":"observables/","title":"Observables","text":"<p>Un Observable \u00e8 un oggetto che rappresenta un flusso di dati nel tempo, utile per gestire eventi asincroni. Si basa sul pattern Observer e viene utilizzato per scambiare messaggi tra due entit\u00e0: il publisher (emettitore) e il subscriber (consumatore). In Angular, tutto questo \u00e8 implementato tramite la libreria RxJS. Gli Observable sono fondamentali per la gestione reattiva e asincrona dei dati, come richieste HTTP, eventi dell\u2019utente o dati che cambiano dinamicamente nel tempo. Un Observable definisce una funzione che emette valori a uno o pi\u00f9 observer. Tuttavia, questa funzione non viene eseguita finch\u00e9 un subscriber non si iscrive utilizzando il metodo <code>subscribe()</code>.</p> <p>Una volta iscritta, l'entit\u00e0 riceve notifiche tramite tre metodi principali:</p> <ul> <li><code>next(value)</code>: emette un nuovo valore al subscriber;</li> <li><code>error(err)</code>: segnala un errore e termina il flusso (nessun altro valore verr\u00e0 emesso dopo);</li> <li><code>complete()</code>: indica che il flusso di dati \u00e8 terminato con successo. Questi tre metodi fungono da handler degli eventi ricevuti.</li> </ul> <p>La ricezione dei dati continua fino a che:</p> <ul> <li>l\u2019Observable completa (ovvero ha finito di emettere valori e notifica ai subscriber la fine del flusso),</li> <li>si verifica un errore,</li> <li>oppure il subscriber si disiscrive manualmente tramite <code>unsubscribe()</code>.</li> </ul> <p> </p> Figura 7: Schema Observable <p>Example</p> <pre><code>// Creazione di un Observable\nimport { Observable } from 'rxjs';\n\nconst esempio$ = new Observable&lt;string&gt;((observer) =&gt; {\n    observer.next('Primo valore');\n    observer.next('Secondo valore');\n\n    // Simula un errore\n    //observer.error('Si \u00e8 verificato un errore');\n\n    // Completa il flusso\n    observer.complete();\n});\n\n// Sottoscrizione all'Observable\nesempio$.subscribe({\n    next: (valore) =&gt; console.log('Ricevuto:', valore), // next: pu\u00f2 essere omesso\n    error: (err) =&gt; console.error('Errore:', err),\n    complete: () =&gt; console.log('Flusso completato')\n});\n</code></pre> <p>Se si scommenta <code>observer.error()</code>, il flusso termina con un errore e <code>complete()</code> non viene mai chiamato.</p>"},{"location":"observables/#rxjs","title":"RxJS","text":"<p>Come gi\u00e0 anticipato, Reactive Extensions for JavaScript (RxJS) \u00e8 una libreria utilizzata da Angular per semplificare lo sviluppo di codice asincrono e basato su eventi, sfruttando la potenza degli Observable.</p> <p>RxJS fornisce:</p> <ul> <li>l\u2019implementazione della classe <code>Observable</code>,</li> <li>una serie di operatori per trasformare, filtrare o combinare flussi di dati,</li> <li>utility per creare Observable a partire da altri tipi di dati, come array, promise, eventi del DOM o timer.</li> </ul> <p>Di seguito vengono illustrati alcuni operatori e creator RxJS in Angular 12: </p> Nome Tipo Categoria Input accettato Descrizione <code>of</code> Creator Creation Valori statici Crea un Observable che emette uno o pi\u00f9 valori statici. <code>from</code> Creator Creation Array, Promise, Iterable Converte un array, promise o iterable in un Observable. <code>fromEvent</code> Creator Creation Eventi DOM Crea un Observable da un evento (es. click, input). <code>map</code> Operatore Transformation Observable Trasforma ogni valore emesso. <code>filter</code> Operatore Filtering Observable Emette solo i valori che soddisfano una condizione. <code>tap</code> Operatore Utility Observable Esegue effetti collaterali senza modificare il flusso. <code>take</code> Operatore Limiting Observable Emette solo i primi N valori. <code>takeUntil</code> Operatore Limiting Observable, Notifier Emette fino a quando un altro Observable emette. <code>switchMap</code> Operatore Flattening (Async) Observable Sostituisce l'Observable precedente con uno nuovo. <code>mergeMap</code> Operatore Flattening (Async) Observable Emette i valori di Observables interni in parallelo. <code>concatMap</code> Operatore Flattening (Async) Observable Emette i valori degli Observables interni in sequenza. <code>catchError</code> Operatore Error Handling Observable Gestisce errori restituendo un Observable alternativo. <code>combineLatest</code> Operatore Combination Pi\u00f9 Observable Combina i valori pi\u00f9 recenti da pi\u00f9 Observable. <code>distinctUntilChanged</code> Operatore Filtering Observable Emette solo se il valore \u00e8 diverso dal precedente."},{"location":"observables/#subject-behaviorsubject-e-replaysubject","title":"Subject, BehaviorSubject e ReplaySubject","text":"<p>In RxJS, <code>Subject</code>, <code>BehaviorSubject</code> e <code>ReplaySubject</code> sono speciali tipi di <code>Observable</code> che, oltre a emettere valori, hanno la capacit\u00e0 di gestire e condividere lo stato tra pi\u00f9 subscriber. Sono utilizzati per multicast (condividere lo stesso stream di dati tra pi\u00f9 abbonati), che differenzia questi tipi di <code>Subject</code> dai normali <code>Observable</code>.</p> <p>Un <code>Subject</code> \u00e8 un <code>Observable</code> che pu\u00f2 emettere valori ai suoi subscriber in modo simile a un normale Observable, ma con una differenza fondamentale: pu\u00f2 multicast, cio\u00e8 inviare lo stesso valore a pi\u00f9 subscriber. <code>Subject</code> non memorizza valori passati, i nuovi subscriber non ricevono i valori precedenti, ma solo quelli emessi dopo essersi iscritti.</p> <p>Un <code>BehaviorSubject</code> \u00e8 un tipo di <code>Subject</code> che mantiene l'ultimo valore emesso e lo invia a tutti i nuovi subscriber immediatamente quando si iscrivono. <code>BehaviorSubject</code> richiede un valore iniziale al momento della creazione. \u00c8 utile quando si vuole che i subscriber ricevano sempre l'ultimo stato disponibile.</p> <p>Un <code>ReplaySubject</code> \u00e8 simile a un <code>BehaviorSubject</code>, ma anzich\u00e9 memorizzare solo l'ultimo valore emesso, memorizza una cronologia di valori. Quando un nuovo subscriber si iscrive, riceve un numero specificato di valori passati. Questo lo rende utile quando si vuole che i subscriber ricevano una serie di valori precedenti.</p> <p>Riassumendo: </p> Tipo Memorizza l'ultimo valore Nuovi subscriber ricevono... Utilizzo tipico <code>Subject</code> No Solo valori emessi dopo l'iscrizione Multicasting senza stato persistente <code>BehaviorSubject</code> S\u00ec L'ultimo valore emesso Gestione dello stato corrente <code>ReplaySubject</code> S\u00ec (numero definito di valori) I valori recenti fino al limite specificato Riprodurre la cronologia degli eventi"},{"location":"observables/#pipe","title":"Pipe( )","text":"<p>Il metodo <code>pipe()</code> consente di comporre una catena di operatori sui oggetti <code>Observable</code>. Ogni operatore all\u2019interno della pipe riceve i dati emessi dall\u2019Observable precedente, li elabora, e li passa all\u2019operatore successivo.</p> <p>Example</p> <pre><code>import { of } from 'rxjs';\nimport { map, filter } from 'rxjs/operators';\n\nconst obs$ = of(1, 2, 3, 4, 5).pipe(\n    filter(x =&gt; x % 2 === 0),\n    map(x =&gt; x * 10)\n);\n\nobs$.subscribe(console.log); // Output: 20, 40\n</code></pre> <p>Nell'esempio precedente, dopo aver creato l'Observable, il metodo <code>filter()</code> all'interno di <code>pipe()</code> scarta i numeri dispari. Successivamente, il metodo <code>map()</code> moltiplica per 10 i numeri rimanenti.</p>"},{"location":"pipes/","title":"Pipes","text":"<p>In Angular, le pipe sono speciali operatori che consentono di trasformare i dati direttamente nel template, in modo semplice e dichiarativo. Sono molto utili per formattare dati come date, numeri, stringhe, valute, percentuali e altro, senza dover scrivere codice extra nei componenti. La pipe \u00e8 una classe con il decoratore @Pipe in cui viene definita una funzione che trasforma valori in input in valori in output da visualizzare in una vista. Angular offre un set di pipe built-in attreverso il package @angular/common:</p> Nome Descrizione AsyncPipe Legge il valore da una Promise o da un Observable di RxJS. CurrencyPipe Trasforma un numero in una stringa di valuta, formattata secondo le regole locali. DatePipe Formatta un valore di tipo Date secondo le regole locali. DecimalPipe Trasforma un numero in una stringa con punto decimale, formattata secondo le regole locali. I18nPluralPipe Mappa un valore a una stringa che lo pluralizza secondo le regole locali. I18nSelectPipe Mappa una chiave a un selettore personalizzato che restituisce un valore desiderato. JsonPipe Trasforma un oggetto in una rappresentazione stringa tramite <code>JSON.stringify</code>, utile per il debug. KeyValuePipe Trasforma un oggetto o una mappa in un array di coppie chiave-valore. LowerCasePipe Trasforma il testo in minuscolo. PercentPipe Trasforma un numero in una stringa percentuale, formattata secondo le regole locali. SlicePipe Crea un nuovo array o una nuova stringa contenente una porzione (slice) degli elementi. TitleCasePipe Trasforma il testo in formato titolo (maiuscola all\u2019inizio di ogni parola). UpperCasePipe Trasforma il testo in maiuscolo."},{"location":"pipes/#utilizzo","title":"Utilizzo","text":"<p>L'operatore pipe di Angular utilizza il carattere della barra verticale (|) all'interno di un'espressione nel template. \u00c8 un operatore binario: l'operando a sinistra rappresenta il valore da trasformare, mentre l'operando a destra indica il nome della pipe e gli eventuali parametri aggiuntivi.</p> <p>Example</p> <pre><code>  &lt;p&gt;Totale: {{ amount | currency }}&lt;/p&gt;\n</code></pre> <p>Per specificare un parametro aggiuntivo, basta inserire due punti (:) dopo il nome della pipe, seguiti dal valore del parametro.</p> <p>Example</p> <pre><code>  &lt;p&gt;L'evento si terr\u00e0 alle {{ scheduledOn | date:'hh:mm' }}.&lt;/p&gt;\n</code></pre> <p>Nel caso di pi\u00f9 parametri</p> <p>Example</p> <pre><code>  &lt;p&gt;L'evento si terr\u00e0 alle {{ scheduledOn | date:'hh:mm':'UTC' }}.&lt;/p&gt;\n</code></pre>"},{"location":"pipes/#pipes-custom","title":"Pipes Custom","text":"<p>In Angular \u00e8 possibile definire delle pipes custom.</p> <p>Example</p> <pre><code>@Pipe({ name: 'reverse' })\nexport class ReversePipe implements PipeTransform {\n    transform(value: string): string {\n        return value.split('').reverse().join('');\n    }\n}\n</code></pre> <p>La pipe ha il nome 'reverse', quindi potr\u00e0 essere utilizzata nei template con la sintassi {{ valore | reverse }}. La classe ReversePipe implementa l'interfaccia PipeTransform, il che significa che deve definire un metodo transform. Questo metodo riceve un valore in input, in questo caso una stringa, e restituisce una nuova stringa con i caratteri invertiti. </p> <p>Opzionalmente possono essere aggiunto parametri aggiuntivi indicandoli in input nel metodo trasform.</p>"},{"location":"pipes/#pipes-pure","title":"Pipes Pure","text":"<p>Per ottimizzare le performance, Angular mette a disposizione le pipe pure. Le pipe pure in Angular sono pipe che vengono eseguite solo quando cambia l\u2019input di riferimento, ossia quando cambia effettivamente il valore passato alla pipe (o uno dei suoi argomenti).</p> <p>Per indicare una pipe come pure basta aggiungere nel decoratore @Pipe, true nel campo pure.</p> <p>Example</p> <pre><code>@Pipe({ \n    name: 'reverse', \n    pure: true,\n})\n</code></pre>"},{"location":"routing/","title":"Routing","text":"<p>In Angular, le routes (rotte) sono il meccanismo che consente di gestire la navigazione tra viste (routing) in una Single Page Application (SPA). Il modulo che gestisce questa funzionalit\u00e0 \u00e8 il <code>RouterModule</code>.</p>"},{"location":"routing/#impostare-il-routing","title":"Impostare il routing","text":"<p>Per impostare il routing occore specificare qual\u2019\u00e8 l\u2019URL di base da cui il router pu\u00f2 comporre gli URL per tutte le view. L\u2019URL di base \u00e8 impostato nel file <code>index.html</code> con il tag <code>&lt;base&gt;</code> (<code>&lt;base href=\"/\"&gt;</code>) all'interno del tag <code>&lt;head&gt;</code></p> <p>Si specificano poi nel modulo le rotte attraverso l'oggetto Routes</p> <p>Example</p> <pre><code>// app-routing.module.ts\nconst routes: Routes = [\n    { path: '', component: HomeComponent },             // rotta base\n    { path: 'about', component: AboutComponent },       // rotta /about\n    { path : '** ', component : PageNotFoundComponent } // rotta wildcard,\n];\n</code></pre> <p>Un oggetto Routes \u00e8 un array di oggetti Routes che hanno se seguenti propriet\u00e0:</p> Propriet\u00e0 Tipo Descrizione <code>path</code> <code>string</code> Il percorso dell'URL che attiva la rotta (es. <code>'home'</code>, <code>'user/:id'</code>). <code>component</code> <code>Type&lt;any&gt;</code> Il componente da visualizzare quando il percorso viene attivato. <code>redirectTo</code> <code>string</code> Percorso verso cui reindirizzare in caso di corrispondenza. <code>pathMatch</code> <code>'full'</code> | <code>'prefix'</code> Specifica come confrontare il path: <code>'full'</code> per corrispondenza completa, <code>'prefix'</code> per parziale (default). <code>children</code> <code>Route[]</code> Array di rotte figlie per creare una struttura gerarchica (nested routes). <code>loadChildren</code> <code>string</code> | <code>() =&gt; ...</code> Permette il lazy loading di un modulo figlio. <code>canActivate</code> <code>any[]</code> Array di guardie che controllano se la rotta pu\u00f2 essere attivata. <code>canActivateChild</code> <code>any[]</code> Guardie applicate ai figli della rotta. <code>canDeactivate</code> <code>any[]</code> Guardie che decidono se \u00e8 possibile uscire dalla rotta corrente. <code>canLoad</code> <code>any[]</code> Guardie che decidono se un modulo pu\u00f2 essere caricato (usato con <code>loadChildren</code>). <code>resolve</code> <code>{ [key: string]: any }</code> Oggetto che associa chiavi a resolver per caricare dati prima di attivare la rotta. <code>data</code> <code>{ [key: string]: any }</code> Oggetto contenente dati statici (es. titolo, meta, flag) associati alla rotta. <code>runGuardsAndResolvers</code> <code>'paramsChange' \\| 'pathParamsChange' \\| 'always'</code> Specifica quando ricaricare guardie e resolver se la rotta \u00e8 gi\u00e0 attiva. (solo per Angular 12) <code>outlet</code> <code>string</code> Nome dell\u2019outlet dove caricare il componente (default: <code>'primary'</code>). <p>Note</p> <p>L'ordine delle rotte \u00e8 importante perch\u00e9 il Router utilizza una strategia \"prima corrispondenza vince\" quando effettua il matching delle rotte. Per questo motivo, le rotte pi\u00f9 specifiche devono essere elencate prima di quelle meno specifiche.</p> <p>Elenca quindi per prime: - le rotte con un percorso statico, - poi una rotta con percorso vuoto (''), che rappresenta la rotta di default, - e infine la wildcard route ('**'), che corrisponde a qualsiasi URL e viene selezionata solo se nessun'altra rotta corrisponde prima.</p> <p>Una volta definite le rotte \u00e8 necessario richiamare il metodo <code>forRoot()</code> (spiegato nel capitolo dedicato ai moduli).</p> <p>Example</p> <pre><code>// app-routing.module.ts\n\nconst routes: Routes = [\n    { path: '', component: HomeComponent },           \n    { path: 'about', component: AboutComponent },\n    { path : '** ', component : PageNotFoundComponent }    \n];\n\n@NgModule({\n    imports: [RouterModule.forRoot(routes)],\n    exports: [RouterModule]\n})\nexport class AppRoutingModule {}\n</code></pre> <p>Il modulo \u00e8 configurato con le route ed esportato agli altri moduli dell\u2019applicazione (Ad esempio nell'AppModule). Se si vuole definire delle sotto rotte in un altro modulo si dovr\u00e0 utilizzare il metodo <code>forChild()</code>. Infine nel file <code>index.html</code>, inserire la direttiva <code>&lt;router-outlet&gt;</code>. L\u2019elemento specifica in quale posto del DOM vanno inserite le varie view gestite dal router.</p>"},{"location":"routing/#routerlink","title":"RouterLink","text":"<p>Un modo semplice per abilitare la navigazione tra le pagine in un'applicazione Angular \u00e8 l'utilizzo della direttiva <code>RouterLink</code>. Quando applicata a un elemento del DOM, <code>RouterLink</code> trasforma l'elemento in un collegamento che, se cliccato, attiva la navigazione verso una specifica route definita nel router. La navigazione risultante visualizzer\u00e0 uno o pi\u00f9 componenti instradati all\u2019interno di uno o pi\u00f9 elementi <code>&lt;router-outlet&gt;</code> presenti nella pagina.</p> <p>Example</p> <pre><code>&lt;li class=\"nav-item\"&gt;\n    &lt;a \n        class=\"nav-link\" \n        routerLink=\"/tariffe\" \n        routerLinkActive=\"active\"&gt;\n        Tariffe\n    &lt;/a&gt;\n&lt;/li&gt;\n</code></pre>"},{"location":"routing/#path-params","title":"Path params","text":"<p>In Angular, per passara i path params basta aggiungere nella rotta \":\" seguito dal nome del parametro.</p> <p>Example</p> <pre><code>// app-routing.module.ts\n...\nconst routes: Routes = [\n    { path: '', component: HomeComponent },           \n    { path: 'about', component: AboutComponent },\n    { path: 'user/:id', component: UserComponent },\n    { path : '** ', component : PageNotFoundComponent }    \n];\n...\n</code></pre> <p>Tramite <code>routerLink</code> bastera indicare il nome della rotta e il valore da comunicare:  <code>&lt;a [routerLink]=\"['/user', 42]\"&gt;Vai a User 42&lt;/a&gt;</code>, oppure tramite typescript <code>this.router.navigate(['/user', 42]);</code>.</p> <p>per leggere i valori nel component occore utilizzare il service <code>ActivatedRoute</code>:</p> <p>Example</p> <pre><code>import { ActivatedRoute } from '@angular/router';\n\nconstructor(private route: ActivatedRoute) {}\n\nngOnInit() {\n    this.route.paramMap.subscribe(params =&gt; {\n        const id = params.get('id');\n    });\n}\n</code></pre>"},{"location":"routing/#nesting-routes","title":"Nesting routes","text":"<p>Le rotte annidate (nesting routes) in Angular permettono di organizzare l\u2019applicazione inserendo componenti figli all\u2019interno di un componente genitore, sfruttando il sistema di routing. Quando l\u2019app cresce in complessit\u00e0, pu\u00f2 essere utile definire rotte relative a componenti diversi da quello radice, per strutturare meglio la navigazione e la visualizzazione dei contenuti.</p> <p>In questi casi, viene introdotto un secondo <code>&lt;router-outlet&gt;</code> all\u2019interno del componente genitore, in aggiunta a quello gi\u00e0 presente nell\u2019<code>AppComponent</code>.</p> <p>Ad esempio, supponiamo di avere due componenti figli: <code>child-a</code> e <code>child-b</code>. Il componente <code>FirstComponent</code>, che funge da contenitore, include un proprio <code>&lt;nav&gt;</code> e un secondo <code>&lt;router-outlet&gt;</code>, nel quale verranno renderizzati dinamicamente i componenti figli in base alla rotta attiva.</p> <p>Example</p> <pre><code>&lt;h2&gt;First Component&lt;/h2&gt;\n&lt;nav&gt;\n    &lt;ul&gt;\n        &lt;li&gt;&lt;a routerLink=\"child-a\"&gt;Child A&lt;/a&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;a routerLink=\"child-b\"&gt;Child B&lt;/a&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/nav&gt;\n&lt;router-outlet /&gt;\n</code></pre> <p>Una rotta figlia \u00e8 come qualsiasi altra rotta: ha bisogno sia di un percorso (path) che di un componente. L\u2019unica differenza \u00e8 che le rotte figlie vengono definite all\u2019interno di un array children all\u2019interno della rotta padre.</p> <p>Example</p> <pre><code>const routes: Routes = [\n    {\n        path: 'first-component',\n        component: FirstComponent,\n        children: [\n            {\n                path: 'child-a',\n                component: ChildAComponent,\n            },\n            {\n                path: 'child-b',\n                component: ChildBComponent,\n            },\n        ],\n    },\n];\n</code></pre>"},{"location":"routing/#guardie","title":"Guardie","text":"<p>Le guardie in Angular sono dei meccanismi di protezione che permettono di controllare l\u2019accesso alle rotte della tua applicazione. Le guardie eseguono controlli prima di attivare, disattivare, caricare o uscire da una rotta.</p> <p>Di seguito viene riportato un esempio di guardia per controllare se lo user ha effettuato il login e quindi accedere alla dashboard:</p> <p>Example</p> <pre><code>@Injectable({\n    providedIn: 'root'\n})\nexport class AuthGuard implements CanActivate {\n    constructor(private authService: AuthService, private router: Router) {}\n\n    canActivate(): boolean {\n        if (this.authService.isLoggedIn()) {\n            return true;\n        }\n        this.router.navigate(['/login']);\n        return false;\n    }\n}\n</code></pre> <p>Viene implementata l'interfaccia <code>CanActivate</code> definendo il metodo <code>canActivate</code>.</p> <p>Example</p> <pre><code>const routes: Routes = [\n    { path: 'dashboard', component: DashboardComponent, canActivate: [AuthGuard] },\n    { path: 'login', component: LoginComponent }\n];\n</code></pre> <p>Utilizzando la propriet\u00e0 dell'oggetto Route dedicata alle guardie pi\u00f9 idonea (vedi tabella dedicata all'oggetto Route), viene aggiunta la guardia <code>AuthGuard</code>.</p>"},{"location":"routing/#lazy-loading","title":"Lazy loading","text":"<p>In Angular, \u00e8 possibile configurare le rotte per caricare i moduli/componenti in modo lazy (caricamento a richiesta), il che significa che Angular carica i moduli/componenti solo quando necessario, invece di caricarli tutti all'avvio dell'applicazione.</p> <p>Ogni rotta pu\u00f2 caricare lazy il proprio modulo/componente stand-alone utilizzando loadComponent:</p> <p>Example</p> <pre><code>const routes: Routes = [\n    {\n        path: 'lazy',\n        loadComponent: () =&gt; import('./lazy.component').then(c =&gt; c.LazyComponent)\n    }\n];\n</code></pre> <p>Con <code>loadComponent: () =&gt; import('./lazy.component')...</code> viene usato il lazy loading di un componente stand-alone. Angular non carica immediatamente <code>LazyComponent</code> all\u2019avvio dell\u2019applicazione, ma solo quando l\u2019utente naviga a /lazy. Con <code>.then(c =&gt; c.LazyComponent)</code>, dopo l\u2019importazione dinamica del file <code>lazy.component.ts</code>, si estrae il <code>LazyComponent</code> dal modulo importato.</p>"},{"location":"services/","title":"Services","text":"<p>In Angular, un servizio \u00e8 una classe che contiene logica riutilizzabile e funzionalit\u00e0 condivise tra pi\u00f9 componenti o moduli. Permette di organizzare il codice, separando le responsabilit\u00e0: ad esempio, anzich\u00e9 scrivere la logica di accesso ai dati direttamente in un componente, si crea un servizio dedicato, e il componente lo utilizza quando necessario, rendendo cos\u00ec l\u2019applicazione pi\u00f9 flessibile inserendo un provider dedicato all'accesso dati.</p> <p>Un servizio pu\u00f2 occuparsi di per esempio: chiamate HTTP a un'API, gestione dello stato dell'applicazione, operazioni matematiche, accesso a dati locali, formattazioni, e cos\u00ec via. Un servizio \u00e8 una classe TypeScript annotata con il decoratore <code>@Injectable()</code>.</p>"},{"location":"services/#dependency-injection","title":"Dependency Injection","text":"<p>Per usare un servizio in un componente, Angular usa un meccanismo chiamato Dependency Injection. </p> <p>La Dependency Injection \u00e8 un meccanismo che fornisce automaticamente le dipendenze richieste da una classe, senza che sia la classe stessa a crearle. Quindi un oggetto (consumer) delega il compito di fornire le dipendenze necessarie a del codice esterno (injector). In Angular, le dipendenze sono in genere servizi, ma possono essere anche altri oggetti o classi.</p> <p> </p> Figura 6: Schema funzionamento DI <p>Se un componente ha bisogno di un servizio, Angular lo \"inietta\" nel costruttore del componente:</p> <p>Example</p> <pre><code>@Component({...})\nexport class ProfiloComponent implements OnInit {\n    constructor(private datiUtenteService: DatiUtenteService) {}\n\n    ngOnInit(): void {\n        const nome = this.datiUtenteService.getNomeUtente();    \n    }\n}\n</code></pre> <p>In questo esempio, Angular crea un'istanza di <code>DatiUtenteService</code> e la passa al costruttore di <code>ProfiloComponent</code> automaticamente. Il componente non si preoccupa di come viene creato il servizio, si limita a usarlo. Perci\u00f2, un componente che vuole utilizzare il servizio inserisce la sua dichiarazione nel costruttore. E\u2019 fondamentale annotare il parametro con il tipo corretto che sar\u00e0 la chiave usata dall\u2019injector per capire che istanza iniettare.</p>"},{"location":"services/#injectables","title":"Injectables","text":"<p>Come scritto precedentemente, i servizi possono essere iniettati in un componente come dipendenze, e un servizio \u00e8 una classe che utilizza il decoratore <code>@Injectable</code>. Inoltre un servizio puo avere sua volta delle dipendenze.</p> <p>Nel seguente esempio viene mostrato come creare un servizio che a sua volta ha una dipendenza, risolta tramite l'injection. </p> <p>Example</p> <pre><code>import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Injectable({\nprovidedIn: 'root'\n})\nexport class UtenteService {\n    constructor(private http: HttpClient) {}\n\n    getUtenti() {\n        return this.http.get('/api/utenti');\n    }\n}\n</code></pre> <p>Nell'esempio <code>@Injectable</code> contiene dei metadati. Infatti, la propriet\u00e0 <code>providedIn</code> indica a Angular dove registrare il servizio nel sistema di iniezione delle dipendenze.  Di seguito i valori che puo assumere: - 'root': \u00c8 l'opzione pi\u00f9 comune e consigliata. Significa che il servizio sar\u00e0 disponibile  ovunque nell\u2019applicazione, quindi creato una sola volta (singleton) e sar\u00e0 caricato automaticamente da Angular, senza doverlo registrare manualmente nel modulo. - 'any': Questa opzione crea istanze separate del servizio in ogni modulo che lo richiede, utile per servizi che non devono condividere stato tra moduli. - 'SomeModule' : permette di indicare un modulo specifico in cui fornire il servizio. Questo \u00e8 utile quando vuoi limitare l\u2019ambito del servizio a un modulo particolare (come un modulo lazy-loaded). Nel providedIn deve essere indicato il nome del modulo, per esempio: <code>providedIn: MyFeatureModule</code></p>"},{"location":"services/#providers","title":"Providers","text":"<p>Nel capitolo dedicato ai componenti, abbiamo visto che il decoratore <code>@Component</code> include una propriet\u00e0 chiamata <code>providers</code>. In Angular, i providers rappresentano il meccanismo attraverso cui viene definito come fornire i servizi (dependencies) all\u2019interno dell\u2019applicazione, utilizzando il sistema di Dependency Injection. Quando un servizio viene registrato come provider, si comunica ad Angular come creare o recuperare un'istanza di quel servizio. Sar\u00e0 poi compito dell'Injector mantenere e gestire la mappa tra i token (le chiavi) e le istanze associate.</p> <p>Abbiamo gi\u00e0 incontrato la registrazione tramite <code>@Injectable({ providedIn: 'root' })</code>, che rende il servizio un singleton a livello globale, condiviso da tutta l\u2019applicazione. Tuttavia, \u00e8 anche possibile registrare un servizio direttamente all\u2019interno della propriet\u00e0 providers di un componente: in questo modo il servizio \u00e8 scoped al componente stesso, ovvero vive solo finch\u00e9 vive il componente, e ogni istanza del componente riceve una propria istanza del servizio.</p> <p>Example</p> <pre><code>@Component({\n    ....\n    providers: [LoggerService]  // provider locale al componente\n    })\n    export class ChildComponent {\n    constructor(private logger: LoggerService) {}\n\n    logMessage() {\n        this.logger.log('Messaggio dal ChildComponent');\n    }\n\n}\n</code></pre> <p>In questo esempio, Angular crea un\u2019istanza locale di <code>LoggerService</code> per ogni istanza del componente. L'istanza viene creata tramite il costruttore della classe, sfruttando implicitamente la strategia <code>useClass</code>, in cui si specifica solo la chiave (<code>LoggerService</code>) e Angular deduce la classe da instanziare.</p> <p>Example</p> <pre><code>@Component({\n    ....\n    providers: [{ provide: LoggerService, useClass: LoggerService }]\n    })\n</code></pre> <p>La configurazione estesa di un provider \u00e8 un oggetto letterale con due propriet\u00e0: - La propriet\u00e0 provide contiene il token, che funge da chiave per richiedere il valore della dipendenza. - La seconda propriet\u00e0 \u00e8 un oggetto di definizione del provider, che indica all\u2019injector come creare il valore della dipendenza. La definizione del provider sar\u00e0 tratta nelle prossime sezioni.</p>"},{"location":"services/#useclass","title":"useClass","text":"<p>Permette di fornire una classe alternativa quando viene richiesto un certo token. useClass consente di creare e restituire una nuova istanza della classe specificata.</p> <p>Example</p> <pre><code>@Component({\n    ....\n    providers: [{ provide: MyService, useClass: MockService }]\n    })\n</code></pre> <p>In questo caso, qualsiasi classe che richieda <code>MyService</code> ricever\u00e0 in realt\u00e0 un\u2019istanza di <code>MockService</code>.</p> <p>Per rendere il servizio disponibile in tutta l\u2019applicazione, lo stesso provider pu\u00f2 essere registrato direttamente nella definizione del modulo root. In questo modo sar\u00e0 usata una sola istanza di <code>MockService</code> per tutti i componenti del modulo.</p>"},{"location":"services/#useexisting","title":"useExisting","text":"<p>useExisting consente di collegare un token a un altro, creando un alias. In questo modo, il primo token diventa un riferimento alternativo al servizio associato al secondo token, permettendo di accedere allo stesso oggetto tramite due nomi diversi.</p> <p>Example</p> <pre><code>@Component({\n    ....\n    providers: [ NewLogger, { provide: OldLogger, useExisting: NewLogger }]\n    })\n</code></pre> <p>Nell\u2019esempio precedente, l\u2019injector fornisce la stessa istanza singleton di <code>NewLogger</code> quando un componente richiede sia <code>NewLogger</code> sia <code>OldLogger</code>. In questo modo, <code>OldLogger</code> \u00e8 un alias di <code>NewLogger</code>.</p> <p>Warning</p> <p>Non utilizzare <code>useClass</code> per creare un alias tra <code>OldLogger</code> e <code>NewLogger</code>, perch\u00e9 questo comporterebbe la creazione di due istanze distinte di <code>NewLogger</code>.</p>"},{"location":"services/#usefactory","title":"useFactory","text":"<p>useFactory permette di generare un oggetto dipendenza attraverso una funzione factory. Questo approccio \u00e8 ideale quando \u00e8 necessario creare valori dinamici, basati su dati disponibili nel sistema di Dependency Injection o provenienti da altre parti dell'applicazione.</p> <p>Nell\u2019esempio seguente, si crea un servizio <code>ApiService</code> che utilizza un valore di configurazione dinamico (apiUrl) fornito da un <code>ConfigService</code>.</p> <p>Example</p> <pre><code>//config.service.ts\nimport { Injectable } from '@angular/core';\n\n@Injectable()\nexport class ConfigService {\n    private environment = 'production';\n    private configs = {\n        development: { apiUrl: 'http://localhost:3000' },\n        production: { apiUrl: 'https://api.example.com' }\n    };\n\n    get apiUrl(): string {\n        return this.configs[this.environment].apiUrl;\n    }\n} \n</code></pre> <pre><code>//api.service.ts\nexport class ApiService {\n    constructor(private apiUrl: string) {}\n\n    getEndpoint(): string {\n        return `${this.apiUrl}/endpoint`;\n    }\n}\n</code></pre> <p>In base all'ambiente viene fornito un url differente da <code>ConfigService</code>. Per utilizzare il useFactory:</p> <p>Example</p> <pre><code>//api.service.provider.ts\nimport { ApiService } from './api.service';\nimport { ConfigService } from './config.service';\n\nexport function apiServiceFactory(config: ConfigService): ApiService {\n    return new ApiService(config.apiUrl);\n}\n\nexport const apiServiceProvider = {\n    provide: ApiService,\n    useFactory: apiServiceFactory,\n    deps: [ConfigService]\n};\n</code></pre> <p>Il campo useFactory specifica che il provider \u00e8 una funzione factory implementata da <code>apiServiceFactory</code>. La funzione factory <code>apiServiceFactory</code> accede a <code>ApiService</code>. La propriet\u00e0 deps \u00e8 un array di token di provider. Angular risolve questi token e inietta i servizi corrispondenti nei parametri della funzione factory, nell\u2019ordine specificato.</p> <p>Example</p> <pre><code>@Component({\n    ...\n    providers: [ConfigService, apiServiceProvider]\n})\nexport class AppComponent {\n endpoint: string;\n\n    constructor(private apiService: ApiService) {\n        this.endpoint = this.apiService.getEndpoint();\n    }\n}\n</code></pre> <p>Nel component dove viene utilizzato <code>ApiService</code>, vengono indicati nel providers il provider factory <code>apiServiceProvider</code> e la sua dipendenza <code>ConfigService</code>.</p>"},{"location":"services/#usevalue","title":"useValue","text":"<p>useValue consente di associare un valore statico a un token di Dependency Injection. Questa tecnica \u00e8 particolarmente utile per fornire costanti di configurazione a runtime, come URL di base, flag di funzionalit\u00e0 o valori predefiniti. Inoltre, \u00e8 molto usata nei test unitari per sostituire servizi reali con dati mock, semplificando la scrittura e il controllo dei test. Per utilizzare useValue occore usare l'oggetto <code>InjectionToken</code> come token del provider per le dipendenze che non sono classi.</p> <p>Example</p> <pre><code>//app.config.ts\nimport { InjectionToken } from '@angular/core';\n\nexport interface AppConfig {\n    title: string;\n}\n\nexport const APP_CONFIG = new InjectionToken&lt;AppConfig&gt;('Descrizione del token app.config');\n</code></pre> <p>Nell\u2019esempio viene definito un token <code>APP_CONFIG</code> di tipo <code>InjectionToken</code>. Il parametro di tipo opzionale <code>&lt;AppConfig&gt;</code> e la descrizione 'Descrizione del token app.config' servono a specificare lo scopo del token.</p> <p>Example</p> <pre><code>//app.component.ts\nconst MY_APP_CONFIG_VARIABLE: AppConfig = {\n    title: 'Ciao',\n};\n\nproviders: [{ provide: APP_CONFIG, useValue: MY_APP_CONFIG_VARIABLE }]\n</code></pre> <p>Viene registrato il provider della dipendenza nel componente usando l\u2019oggetto <code>InjectionToken</code> <code>APP_CONFIG</code>.</p> <p>Example</p> <pre><code>// app.component.ts\nconst MY_APP_CONFIG_VARIABLE: AppConfig = {\n    title: 'Ciao',\n};\n\n@Component({\n    selector: 'app-root',\n    template: `...`,\n    providers: [{ provide: APP_CONFIG, useValue: Y_APP_CONFIG_VARIABLE }]\n})\nexport class AppComponent {\n    apiUrl: string;\n\n    constructor() {\n        const config = inject(APP_CONFIG);\n        this.apiUrl = config.apiUrl;\n    }\n}\n</code></pre> <p>Infine la configurazione del token viene inietta nel costruttore tramite la funzione <code>Inject</code>.</p>"},{"location":"services/#injector","title":"Injector","text":"<p>In Angular, l\u2019Injector \u00e8 il meccanismo centrale che gestisce la creazione e risoluzione delle dipendenze, mantenendo una mappa di provider (token). Normalmente non lo si usa direttamente, perch\u00e9 Angular gestisce automaticamente la Dependency Injection tramite i costruttori. Tuttavia, \u00e8 possibile fare iniezione manuale usando l\u2019Injector, ad esempio in contesti dinamici o avanzati.</p> <p>Nel seguente esempio viene illustrata un iniezione manuale con <code>Inject</code>.</p> <p>Example</p> <pre><code>@Component({\nselector: 'app-example',\ntemplate: `...`,\nproviders: [LoggerService]\n})\n    export class ExampleComponent {\n    constructor(private injector: Injector) {\n        const logger = this.injector.get(LoggerService);\n    }\n}\n</code></pre> <p>Tramite il metodo <code>get()</code> recupera l'istanza del servizio da iniettare.</p>"},{"location":"setup/","title":"Setup","text":"<p>Per installare e usare Angular 7 o 12 occore prima di tutto installare il gestore di package npm:</p> <ul> <li>Download Node 10.24.1 per Angular 7</li> <li>Download Node 12.22.7 per Angular 12</li> </ul> <p>Info</p> <p>Per gestire le versioni di node \u00e8 utile installare NVM.  Scarica nvm-setup.exe per installare npm. Verifica con:</p> <ul> <li><code>nvm version</code> per verificare se NVM \u00e8 stato installato correttamente.</li> <li><code>npm -v</code> per verificare se npm \u00e8 stato installato correttamente.</li> </ul> <p>Si passa poi a installare la Angular CLI:</p> <p><code>npm install -g @angular/cli</code></p> <p>o</p> <p><code>npm install -g @angular/cli@12</code></p> <p>e verificare con il commando <code>ng version</code> per verificare la corretta installazione.</p> <p>Per creare un progetto Angular si utilizza:</p> <p><code>ng new nome-progetto</code></p> <p>e per avviare il progetto: </p> <ul> <li>spostiamoci nella directory con <code>cd nome-progetto</code>, </li> <li><code>ng serve</code> per lanciare il server Angular,</li> <li>collegarsi al http://localhost:4200 nel browser.</li> </ul>"},{"location":"template-driven/","title":"Template-driven form","text":"<p>Il Template-driven form in Angular \u00e8 un approccio per costruire e gestire form in cui la maggior parte della logica \u00e8 scritta direttamente nell\u2019HTML, sfruttando le direttive offerte da Angular (validator degli input). I form utilizzano il two-way data binding (binding bidirezionale) per aggiornare il modello di dati nel componente quando vengono apportate modifiche nel template, e viceversa.</p> <p>Info</p> <p>Angular supporta due approcci di progettazione per i form interattivi:</p> <ul> <li>I form template-driven ti permettono di usare direttive specifiche per i form direttamente nel template Angular (tratteremo solo questi in questa guida).</li> <li>I form reattivi (reactive forms) forniscono un approccio basato sul modello (model-driven) per la costruzione dei form.</li> </ul> <p>I form template-driven sono un\u2019ottima scelta per form semplici o di piccole dimensioni, mentre i form reattivi sono pi\u00f9 scalabili e adatti a form complessi. </p>"},{"location":"template-driven/#costruzione","title":"Costruzione","text":"<p>Per costruire un form con approcio Template-drive occore utilizzare le direttive come <code>ngModel</code>, <code>NgModelGroup</code>, <code>ngForm</code> del modulo <code>FormsModule</code>. Chiaramente tutto il codice del form sara scritto nel template HTML.</p> Direttiva Dettagli NgModel Riconcilia le modifiche di valore nell'elemento del form associato con i cambiamenti nel modello dati, permettendo di gestire l\u2019input utente con validazione ed errori. NgForm Crea un'istanza di <code>FormGroup</code> di livello superiore e la associa a un elemento <code>&lt;form&gt;</code> per tracciare i valori aggregati del form e lo stato di validazione. Importando <code>FormsModule</code>, questa direttiva \u00e8 attiva di default su tutti i tag <code>&lt;form&gt;</code> non serve aggiungere un selettore speciale. NgModelGroup Crea e associa un'istanza di <code>FormGroup</code> a un elemento del DOM. <p>Dopo aver importato il modulo <code>FormsModule</code> nel root module o comunque nel modulo che contiene il component in cui si vuole implementare il form, il form pu\u00f2 essere implemntato nel seguente modo:</p> <p>Example</p> <p><pre><code>&lt;form #f=\"ngForm\" (ngSubmit)=\"onSubmit(f)\"&gt;\n    &lt;label&gt;\n        Nome:\n        &lt;input name=\"nome\" [(ngModel)]=\"utente.nome\" required #nome=\"ngModel\" /&gt;\n    &lt;/label&gt;    \n    &lt;div *ngIf=\"nome.invalid &amp;&amp; nome.touched\"&gt;\n        Il nome \u00e8 obbligatorio.\n    &lt;/div&gt;\n    &lt;label&gt;\n        email:\n        &lt;input name=\"email\" [(ngModel)]=\"utente.email\" email /&gt;\n    &lt;/label&gt;\n\n    &lt;h3&gt;Indirizzo&lt;/h3&gt;\n    &lt;div ngModelGroup=\"indirizzo\"&gt;\n        &lt;label&gt;\n            Via:\n            &lt;input name=\"via\" [(ngModel)]=\"utente.indirizzo.via\" required /&gt;\n        &lt;/label&gt;\n        &lt;label&gt;\n            Citt\u00e0:\n            &lt;input name=\"citta\" [(ngModel)]=\"utente.indirizzo.citta\" required /&gt;\n        &lt;/label&gt;\n        &lt;label&gt;\n            CAP:\n            &lt;input name=\"cap\" [(ngModel)]=\"utente.indirizzo.cap\" required /&gt;\n        &lt;/label&gt;\n    &lt;/div&gt;\n    &lt;button type=\"submit\" [disabled]=\"f.invalid\"&gt;Invia&lt;/button&gt;\n&lt;/form&gt;\n</code></pre> Nel ts la funzione <code>onSubmit()</code> \u00e8 cosi definita: <pre><code>export class AppComponent {\n    utente = {\n        nome: '',\n        indirizzo: {\n        via: '',\n        citta: '',\n        cap: ''\n        }\n    };\n\n    onSubmit(form: any) {\n        console.log('Dati inviati:', form.value);\n    }\n}\n</code></pre></p> <p>Dove: </p> <ul> <li><code>#f=\"ngForm\"</code>: assegna una reference locale al form.</li> <li><code>[(ngModel)]=\"utente.nome\"</code>: crea un two-way binding tra l\u2019input e il modello utente.</li> <li><code>required</code>, <code>email</code>, ecc.: si usano gli attributi HTML per le validazioni.</li> <li><code>f.invalid</code>: Angular gestisce automaticamente la validazione e fornisce propriet\u00e0 come <code>valid</code>, <code>invalid</code>, <code>touched</code>, <code>pristine</code>, ecc.</li> <li><code>ngModelGroup=\"indirizzo\"</code> crea un gruppo logico per i campi dell\u2019indirizzo. I nomi degli input (es. \"via\", \"citta\", ecc.) diventano sotto-propriet\u00e0 del gruppo indirizzo nel modello del form.</li> </ul> <p>L\u2019oggetto <code>form.value</code> avr\u00e0 questa struttura:</p> <pre><code>{\n  nome: 'Mario',\n  indirizzo: {\n    via: 'Via Roma',\n    citta: 'Milano',\n    cap: '20100'\n  }\n}\n</code></pre>"}]}